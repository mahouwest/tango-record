<!DOCTYPE html>
<html>
<head>
	<title>record</title>
	<link rel="stylesheet" type="text/css" href="/general.css">
	<link rel="stylesheet" type="text/css" href="/card.css">
</head>
<body>
	<input type="text" name="search">
	<div class="top">
		<div>example</div>
	</div>
	<div class="container-container">
		<div class="container">
			<% for ( const [tag, tangos] of Object.entries(words.word) ){ %>
			<div class="page">
		    	<div class="cover">
		    		<div class="cover-core"><%= tag %></div>
		    	</div>

		    	<div class="content">

		    		<div class="tag tag-<%= tag %>" data-tag="<%= tag %>"><%= tag %>
			    		<% tangos.forEach((tango) => { %>
			    		<% if(tango.level){ %>
			    		<div class="word word-level-<%= tango.level %>">
			    		<% } else { %>
			    		<div class="word">
			    		<% } %>
			    		    <span class="word-a"><%= tango.write %></span>
			    		    <% if(tango.pronounce){ %>
			    		    <span class="word-b"><%= tango.pronounce %></span>
			    		    <% } else { %>
			    		    <span class="word-b"></span>
			    		    <% } %>
			    		    <span class="word-c"><%= tango.imi %></span>
			    		    <span class="to-right">
								<div class="option">ğŸ”µ</div>
			                </span>
			            </div>
			    	    <% }) %>
			    	</div>

			    	<div class="arata">
			            <div>
		                    <div><%= tag %>ã€€ï¼ï¼</div>
		                    <input type="text" name="write">
		                    <input type="text" name="pronounce">
		                    <input type="text" name="imi">
			                <button data-tag="<%= tag %>">test</button>
			            </div>
			        </div>
	            <!-- content end -->
		    	</div>
	        <!-- page end -->
		    </div>
			<% } %>
		</div>
	</div>
	

	<div class="operator">
			<div class="op-levelup">â†‘â†‘â†‘</div>
			<div class="op-leveldown">â†“â†“â†“</div>
			<a class="op-delete" href="/tango///delete">æ¶ˆé™¤</a>
			<a class="op-update" href="/tango///update">æ›´æ–°</a>
	</div>

	<template class="wordT">
		<div class="word">
			<span class="word-a"></span>
			<span class="word-b"></span>
			<span class="word-c"></span>
			<span class="to-right">
				<div class="option">ğŸ”µ</div>
			</span>
		</div>
	</template>

	<!-- page open -->
	<script type="text/javascript">

		let currentPage;
		function tagOpen(e){
			// console.log(this, e);
			if(currentPage && currentPage !== this){
				currentPage.classList.remove("page-open1");
				currentPage.classList.remove("page-open2");
				currentPage.classList.remove("page-open3");
			}
			this.classList.remove("page-close");
			this.classList.add("page-open1");
			currentPage = this;

			// z-index for box-shadow
			let z = 100;
			currentPage.style.zIndex = z;
			z--;
			let leaf = currentPage;
			while( (leaf = leaf.previousSibling) !== null){
				if(leaf.classList){
					leaf.classList.remove("page-open");
					leaf.classList.add("page-close");
					leaf.style.zIndex = z;
					z--;
				}
			}
			leaf = currentPage;
			while( (leaf = leaf.nextSibling) !== null){
				if(leaf.classList){
					leaf.classList.remove("page-open");
					leaf.classList.add("page-close");
					leaf.style.zIndex = z;
					z--;
				}
			}
		}

		document.querySelectorAll(".page").forEach((page) => {
			page.addEventListener("click", function(e){
				tagOpen.call(this, e);
			});

			page.addEventListener("transitionend", async function(e){
				// console.log(e); 
				function* classListGenerator(){
					page.classList.add("page-open2");
					yield "pageOpen2";
					page.classList.add("page-open3");
					yield "pageOpen3";
					return "end";
				}
				if(this === currentPage){
					if(e.propertyName.includes("flex")){
						let ty = classListGenerator();
						ty.next();
						setTimeout(() => ty.next(), 10);
						// callback not work, only setTimeout
					}
				}
			});

		});
	</script>

	<!-- operation -->
	<script type="text/javascript">
		(function(){})();


		let operator = document.querySelector(".operator");
		const tags = document.querySelectorAll(".tag");
		let word;

		// è¨»å†Šæ“ä½œé¸å–®äº‹ä»¶
		tags.forEach((tag) => {
			// arrow function will not work with "this"
			tag.addEventListener("click", function(e){
				if(e.target.classList.contains("option")){
					operator.style.top = `${e.pageY + 1}px`;
					operator.style.left = `${e.pageX + 1}px`;
					word = e.target.parentNode.parentNode;
					const tango = word.querySelector(".word-a").innerText;
					operator.querySelector(".op-delete").href = `/tango/${this.dataset.tag}/${tango}/delete`;
					operator.querySelector(".op-update").href = `/tango/${this.dataset.tag}/${tango}/update`;
					operator.dataset.tag = this.dataset.tag;
					operator.dataset.tango = tango;
					operator.classList.add("operator-active");
					e.stopPropagation();
				}
			});
		});

		// è¨»å†Šæ“ä½œäº‹ä»¶
		operator.addEventListener("click", function(e){

			// ä¸Šä¸‹
			if(e.target.classList.contains("op-levelup") || e.target.classList.contains("op-leveldown")){
				// ç§»é™¤class (æš«æ™‚)
				if( word ){
		            word.classList.remove("word-level-1");
		            word.classList.remove("word-level-2");
		            word.classList.remove("word-level-3");
				}

				// request body
		        let req = new URLSearchParams();
				if(e.target.classList.contains("op-levelup")){
					req.append("level", "rise");
				}
				else if(e.target.classList.contains("op-leveldown")){
					req.append("level", "fall");
				}

				// request
				if( this.dataset.tag && this.dataset.tango && word ){
					fetch(`/tango/${this.dataset.tag}/${this.dataset.tango}/update`, {
		                method: "POST",
		                body: req
		            })
		            .then(() => {
		                fetch("/word_new.json")
		                .then((res) => {
		                    return res.json();
		                })
		                .then((data) => {
		                    word.classList.add(`word-level-${data.level}`);
		                });
		            });
				}
			}
			// æ¶ˆé™¤
			else if(e.target.classList.contains("op-delete")){
				e.preventDefault();
				fetch(e.target.href)
				.then((res) => {
					return res.json();
				})
				.then((data) => {
					if(data["delete"] && word ){
						word.remove();
					}
					console.log("æ¶ˆé™¤", data.delete);
				});
			}
	        
            
		});

		document.querySelector("body").addEventListener("click", (e) => {
			if(operator.classList.contains("operator-active")){
				operator.classList.remove("operator-active");
			}
		});
	</script>

	<!-- new tango request -->
	<script type="text/javascript">
		const arata = document.querySelectorAll(".arata");
		const templateWord = document.querySelector(".wordT");
		function newWordDOM(data, tag){
			// duplicate node
			let tmp = document.importNode(templateWord.content, true);
			tmp.querySelector(".word-a").textContent = data.write;
			tmp.querySelector(".word-b").textContent = data.pronounce;
			tmp.querySelector(".word-c").textContent = data.imi;
			document.querySelector(`.tag-${tag}`).appendChild(tmp);
		}
		arata.forEach((arata) => {
			const trigger = arata.querySelector("[data-tag]");
			const inputWrite = arata.querySelector("[name=write]");
			const inputPronounce = arata.querySelector("[name=pronounce]");
			const inputImi = arata.querySelector("[name=imi]");
			trigger.addEventListener("click", (e) => {
				// request body
				let tango = new URLSearchParams();
				tango.append("write", inputWrite.value);
				tango.append("pronounce", inputPronounce.value);
				tango.append("imi", inputImi.value);
				fetch(`/tango/${trigger.dataset.tag}/new`, {
					method: "POST",
					body: tango
				})
				.then((res) => {
					inputWrite.value = "";
					inputPronounce.value = "";
					inputImi.value = "";
					return res.json();
				})
				.then((data) => {
					newWordDOM(data, trigger.dataset.tag);
				});
			});
		});
	</script>

	<!-- search -->
	<script type="text/javascript">

		const katakana_t = ["ã‚¢", "ã‚¤", "ã‚¦", "ã‚¨", "ã‚ª", "ã‚«", "ã‚­", "ã‚¯", "ã‚±", "ã‚³", "ã‚µ", "ã‚·", "ã‚¹", "ã‚»", "ã‚½", "ã‚¿", "ãƒ", "ãƒ„", "ãƒ†", "ãƒˆ", "ãƒŠ", "ãƒ‹", "ãƒŒ", "ãƒ", "ãƒ", "ãƒ", "ãƒ’", "ãƒ•", "ãƒ˜", "ãƒ›", "ãƒ", "ãƒŸ", "ãƒ ", "ãƒ¡", "ãƒ¢", "ãƒ¤", "ãƒ¦", "ãƒ¨", "ãƒ©", "ãƒª", "ãƒ«", "ãƒ¬", "ãƒ­", "ãƒ¯", "ãƒ²", "ãƒ³", "ã‚¬", "ã‚®", "ã‚°", "ã‚²", "ã‚´", "ã‚¶", "ã‚¸", "ã‚º", "ã‚¼", "ã‚¾", "ãƒ€", "ãƒ‚", "ãƒ…", "ãƒ‡", "ãƒ‰", "ãƒ", "ãƒ“", "ãƒ–", "ãƒ™", "ãƒœ", "ãƒ‘", "ãƒ”", "ãƒ—", "ãƒš", "ãƒ", "ãƒ£", "ãƒ¥", "ãƒ§", "ãƒƒ", "ã‚¡", "ã‚£", "ã‚¥", "ã‚§", "ã‚©", "ãƒ´"];
		const hiragana_t = ["ã‚", "ã„", "ã†", "ãˆ", "ãŠ", "ã‹", "ã", "ã", "ã‘", "ã“", "ã•", "ã—", "ã™", "ã›", "ã", "ãŸ", "ã¡", "ã¤", "ã¦", "ã¨", "ãª", "ã«", "ã¬", "ã­", "ã®", "ã¯", "ã²", "ãµ", "ã¸", "ã»", "ã¾", "ã¿", "ã‚€", "ã‚", "ã‚‚", "ã‚„", "ã‚†", "ã‚ˆ", "ã‚‰", "ã‚Š", "ã‚‹", "ã‚Œ", "ã‚", "ã‚", "ã‚’", "ã‚“", "ãŒ", "ã", "ã", "ã’", "ã”", "ã–", "ã˜", "ãš", "ãœ", "ã", "ã ", "ã¢", "ã¥", "ã§", "ã©", "ã°", "ã³", "ã¶", "ã¹", "ã¼", "ã±", "ã´", "ã·", "ãº", "ã½", "ã‚ƒ", "ã‚…", "ã‚‡", "ã£", "ã", "ãƒ", "ã…", "ã‡", "ã‰", "ã‚”"];
		let kl = katakana_t.length;
		function hiragana(katakana){
			if(katakana){
				return [].map.call(katakana, (k) => {
					for(let i = 0; i < kl; i++){
						if(k === katakana_t[i]){
							return hiragana_t[i];
						}
					}
					return k;
				}).join("");
			}
		}

		function Search(){
			this.words = document.querySelectorAll(".word");
			this.wordsText_transformed = [].map.call(this.words, (word) => hiragana(word.textContent) );
			this.result = [];
			this.current;
			this.previous;
			this.input = document.querySelector("[name=search]");
			this.n = 0;

			this.close = function(){
				this.input.classList.remove("search-show");
				this.current = null;
				this.previous = null;
				this.n = 0;
				this.words = document.querySelectorAll(".word");
				// update word data when every time close (to include new word)
				this.wordsText_transformed = [].map.call(this.words, (word) => hiragana(word.textContent) );
			};
			close = close.bind(this);
			this.open = function(){
				this.input.classList.add("search-show");
			};
			open = open.bind(this);
		}
		let search = new Search();

		search.input.addEventListener("keyup", function(e){
			
			if(this.value === ""){
				return;
			}
			if(e.code === "Enter"){
				if(search.result.length === 0){
					search.input.value += ":)";
					return;
				}
				if(search.previous){
				    search.words[search.previous].querySelector(".option").textContent = "ğŸ”µ";
				}
				search.current = search.result[search.n];
				console.dir(search.current);

				tagOpen.call(search.words[search.current].parentNode.parentNode.parentNode, e);
				// window.scroll(0, search.words[search.current].offsetTop);
				let range = document.createRange();
				range.selectNode(search.words[search.current]);
				window.getSelection().removeAllRanges();
				window.getSelection().addRange(range);
				search.words[search.current].querySelector(".option").textContent = "ğŸ”´";
				search.n = ++search.n % search.result.length;
				search.previous = search.current;
				return;
			}
			search.result = [];
			search.wordsText_transformed.forEach((write, n) => {
				if( write.includes(hiragana(this.value)) ){
					search.result.push(n);
				}
			});
			console.log(this.value, search.result);


		});

		document.addEventListener("keydown", function(e){
			// issue: in every input element should block triggering
			if( e.target !== search.input ){
				if(e.key === "f"){
					search.open();
					// é¿å…è¼¸å…¥f
					e.preventDefault();
					search.input.select();
				}
			} else {
				if(e.key === "Escape"){
					search.close();
				}
			}
		});
		document.addEventListener("click", function(e){
			if(e.target !== search.input){
				search.close();
			}
		});
		
		
	</script>


	<script type="text/javascript" src="/blockEnter.js"></script>
</body>
</html>